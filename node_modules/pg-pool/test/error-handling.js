ce="IDB_BITMAP_SCHEDULE_16" src="AcTpCatalogRes.dll" />
              <Image cx="32" cy="32" IsDark="false" resource="IDB_BITMAP_SCHEDULE" src="AcTpCatalogRes.dll" />
              <Image cx="16" cy="16" IsDark="true" resource="IDB_BITMAP_SCHEDULE_16_DARK" src="AcTpCatalogRes.dll" />
              <Image cx="32" cy="32" IsDark="true" resource="IDB_BITMAP_SCHEDULE_DARK" src="AcTpCatalogRes.dll" />
            </Images>
            <Time createdUniversalDateTime="2006-11-22T12:34:45" modifiedUniversalDateTime="2006-11-23T14:23:56" />
          </Properties>
          <Source />
          <ToolType>1</ToolType>
          <StockToolRef idValue="{10C22F88-5A00-44CB-9E2C-0D4BF8BF9814}" />
          <Data>
            <GeneralProperties>
              <Color>
                <BasicPropInfo>
                  <PropValue unspecified="FALSE" />
                </BasicPropInfo>
                <CreateInfo>
                  <AcCmColor mRGB="3221225472" />
                </CreateInfo>
              </Color>
              <Layer>
                <BasicPropInfo>
                  <PropValue unspecified="FALSE" valueType="1" value="0" />
                </BasicPropInfo>
              </Layer>
              <Linetype>
                <BasicPropInfo>
                  <PropValue unspecified="FALSE" valueType="1" value="ByLayer" />
                </BasicPropInfo>
              </Linetype>
              <LinetypeScale>
                <BasicPropInfo>
                  <PropValue unspecified="FALSE" valueType="3" value="1" />
                </BasicPropInfo>
              </LinetypeScale>
              <PlotStyle>
                <BasicPropInfo>
                  <PropValue unspecified="FALSE" valueType="1" value="ByLayer" />
                </BasicPropInfo>
              </PlotStyle>
              <LineWeight>
                <BasicPropInfo>
                  <PropValue unspecified="FALSE" valueType="2" value="-1" />
                </BasicPropInfo>
              </LineWeight>
              <Textstyle>
                <BasicPropInfo>
                  <PropValue unspecified="TRUE" valueType="1" />
                </BasicPropInfo>
              </Textstyle>
              <Dimstyle>
                <BasicPropInfo>
                  <PropValue unspecified="TRUE" valueType="1" />
                </BasicPropInfo>
              </Dimstyle>
              <Tablestyle>
                <BasicPropInfo>
                  <PropValue unspecified="FALSE" valueType="1" value="Schedule" />
                </BasicPropInfo>
                <CreateInfo>
                  <TablestyleInfo isTitleSuppressed="FALSE" isHeaderSuppressed="FALSE" flowDirection="0">
                    <Name>Schedule</Name>
                    <Description>Standard</Description>
                    <HorzCellMargin>0.06</HorzCellMargin>
                    <VertCellMargin>0.06</VertCellMargin>
                    <CellStyles>
                      <CellStyle CellName="_DATA" cellDataType="512" cellUnitType="0" alignment="4" isBackgroundColorNone="TRUE">
                        <TextHeight>0.18</TextHeight>
                        <BackgroundColor>
                          <Color>
                            <BasicPropInfo>
                              <PropValue unspecified="FALSE" />
                            </BasicPropInfo>
                            <CreateInfo>
                              <AcCmColor mRGB="3355443200" />
                            </CreateInfo>
                          </Color>
                        </BackgroundColor>
                        <ContentColor>
                          <Color>
                            <BasicPropInfo>
                              <PropValue unspecified="FALSE" />
                            </BasicPropInfo>
                            <CreateInfo>
                              <AcCmColor mRGB="3221225472" />
                            </CreateInfo>
                          </Color>
                        </ContentColor>
                  const client = yield pool.connect()
        expect(pool.totalCount).to.equal(1)
        expect(pool.waitingCount).to.equal(0)
        expect(pool.idleCount).to.equal(0)

        yield new Promise((resolve, reject) => {
          process.nextTick(() => {
            let poolError
            pool.once('error', (err) => {
              poolError = err
            })

            let clientError
            client.once('error', (err) => {
              clientError = err
            })

            client.emit('error', new Error('expected'))

            expect(clientError.message).to.equal('expected')
            expect(poolError).not.to.be.ok()
            expect(pool.idleCount).to.equal(0)
            expect(pool.totalCount).to.equal(1)
            client.release()
            pool.end().then(resolve, reject)
          })
        })
      })
    )
  })

  describe('passing a function to pool.query', () => {
    it('calls back with error', (done) => {
      const pool = new Pool()
      console.log('passing fn to query')
      pool.query((err) => {
        expect(err).to.be.an(Error)
        pool.end(done)
      })
    })
  })

  describe('pool with lots of errors', () => {
    it(
      'continues to work and provide new clients',
      co.wrap(function* () {
        const pool = new Pool({ max: 1 })
        const errors = []
        for (var i = 0; i < 20; i++) {
          try {
            yield pool.query('invalid sql')
          } catch (err) {
            errors.push(err)
          }
        }
        expect(errors).to.have.length(20)
        expect(pool.idleCount).to.equal(0)
        expect(pool.query).to.be.a(Function)
        const res = yield pool.query('SELECT $1::text as name', ['brianc'])
        expect(res.rows).to.have.length(1)
        expect(res.rows[0].name).to.equal('brianc')
        return pool.end()
      })
    )
  })

  it('should continue with queued items after a connection failure', (done) => {
    const closeServer = net
      .createServer((socket) => {
        socket.destroy()
      })
      .unref()

    closeServer.listen(() => {
      const pool = new Pool({ max: 1, port: closeServer.address().port, host: 'localhost' })
      pool.connect((err) => {
        expect(err).to.be.an(Error)
        if (err.code) {
          expect(err.code).to.be('ECONNRESET')
        }
      })
      pool.connect((err) => {
        expect(err).to.be.an(Error)
        if (err.code) {
          expect(err.code).to.be('ECONNRESET')
        }
        closeServer.close(() => {
          pool.end(done)
        })
      })
    })
  })

  it('handles post-checkout client failures in pool.query', (done) => {
    const pool = new Pool({ max: 1 })
    pool.on('error', () => {
      // We double close the connection in this test, prevent exception caused by that
    })
    pool.query('SELECT pg_sleep(5)', [], (err) => {
      expect(err).to.be.an(Error)
      done()
    })

    setTimeout(() => {
      pool._clients[0].end()
    }, 1000)
  })
})
